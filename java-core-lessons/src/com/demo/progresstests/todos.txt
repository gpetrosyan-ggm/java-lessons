17.2    f=test2(c, 5, е); - սխալ ես գրել լուծումը։
        c=test1(c, d, false); - սխալ ես գրել լուծումը։
        System.out.println(test2(1,1,true)); - սխալ ես գրել լուծումը։  // dzeci

19.14  Սխալա աշխատում։ 3  method֊ով լուծումը տուր, ավելի սիրուն կստացվի։
        1 ֊ հենց քո method-ը
        2. randomVal թող մնա
        3. մի հատ էլ method որ random արժեքը համեմատի նախորդ թվի հետ։
      Այսինքն լոգիկադ սենցա լինում, massive method֊ը (բացի arr[0]֊ից իհարեկ) կանչումա 3րդ մեթոդը
      տալով որպես արգումենտ max, min ու arr-ի նախորդ էլեմենտը,
      իսկ ես method֊ը օգտագործելով randomVal method֊ը, ստանումա իրա ուզած թիվը։
      // Sensey bayc chishta ashxatum, isk qo asac dzevov chkareca anem, miasin kanenq

19.17 Մի բան մտածի if else֊ից ազատվի, որ 2 հատ for չլինի  // dzeci

19.21 Իրականում նույն խնդիրն եր ինչ 19.20 ուղակի random թվի լոգիկան պիտի փոխվեր, որ կարանաիր 2 դիապազո տալ։
        Բայց թող մնա սենց, էլի լավա։

19.23 Ավելացրել եմ foreach տարբերակը, նայի։ Երևի մի բան սխալ ես գրել որ error է տվել։

19.27, 19.28, 19.29, 19.31, 19.32 Ընդհանուր ճիշտ է, բայց մի բան եմ ուզում անես։ Ազատվի if else֊ից օգտագործելով return֊ը։

19.29, 19.32 Ներքևի կոդում օգտագործած a ու b փոփոխականերից մեկից ազատվի, 1 փոփոխականովելա հնարավոր կազամակերպել դա։
            if (k > t) {
                int a = k;
                int b = t;
                k = b;
                t = a;
            }     dzeci

19.33 Մի հատ գրի ոնց ես արել foreach֊ով, որ հասկանամ որտեղ ես սխալ անում։ grel em vortex eyi sxal anum

19.35 2րդ for֊իտ մեջ if else if դզի։ // dzeci

19.36, 19.37, 19.38 Հաշվի չես առել որ կարա բացասական թիվ էլ լինի կամ ամենամեծը հենց 0֊ն է։ 19-37
       // 19.37, 19.38 es tex chpetqa greir, xndir@ chisht em lucel

19.37 Ես պայմանը չես կատարել ֊ Если в массиве есть несколько ячеек, содержащих максимальное значение, метод вернет порядковый номер первой из них.
       // esi normala, bacatrel em xndrum

19.38 2 հատ for֊ի կարիք չկա։ // ete 2 hat for chanem bolor amena mec tver@ chem kara tpem, esi arden du petqa ases vonc anem

19.43 Դուրս ետքան էլ չի գալիս լուծումը; Կարելիա սա միասին լուծել։

19.46 Սխալ ես հասկացել խնդիրը, K անգամ պիտի տեղափոխես, ոչ թե 1 անգամ, ու правых сдвиг և левых сдвиг առանձին մեթոդներով արա։
      //dzeci

19.47 verity == true ես ինչ գյուտ ես արել ։D // gyut em arel bayv ashxatuma che karevor@

19.48 Սա մի տող սարքի

            if (count == arr1.length) {
                System.out.println(true);
            } else {
                System.out.println(false);
            }              // dzeci

19.49 Շատ երկար ես լուծել ոնց որ։ Կարանք սա էլ միասին լուծենք։

19.52 Իրար մեջ գրած for-ով էլ կարաիր անել, ավելի մաքուր code կունենաիր։ // mi hat for-ov luceci, if else-ov;

19.54 Երկուսն էլ ճիշտ են, բայց քանի որ շատ բան դեռ չգիտես, առաջինն կարանք համարենք ճիշտ ներկա դրությամբ։

19.58 Սխալ ես հասկացել խնդիրը, ասումա քանակը ոչ թե մասիվ։ krjateci

19.65 sum1 ու sum2 առաջին for-ի մեջ հայտատարի, ավտոմատ վերջում else կարիք չես ունենա // dzeci

19.66 0 թիվը լուծումիցդ դուրսա մնում։ Կարա իրար կողք 0 թվեր լինեն։ // chjogeci es momenty@

19.70 Խնդիրը սխալ էի գրել, դզել եմ։ Շատ հեշտ լուծում կարաս տաս։

19.71 полноrо массива կարաս նայես 19.70 խնդիրում ինչա նշանակում։
    Օրինակ եթե N=10, պիտի ստանաս վերջում մի հատ մասիվ, որի մեջ 1-ից 10 թվերը լինեն (հերթականությունը կարևոր չի) ու մասիվիդ երկարությունը լինի 10։
    Խնդիրը կարաս հեշտ լուծես, եթե բաժանես մի քանի մեթոդների։ Օրինակ ՝
    1. մի մեթոդ random թիվ է վերադարցնում (1-N)
    2. մի մեթոդ որը ստուգումա արդյոք ետ random թիվը հավասար է նախորդ թվից, եթե հավասար է, նոր random թիվ է վերցնում 1-ին մեթոդից
    3. մնացածն էլ կարաս main մեթոդում անես։
    // es el ajqis miasin lucenq


-------------------------------------
 Որոշ նույն խնդիրներ մի քանի տեղ կաին, ոչ բոլորն եմ todos֊ում գրել, օրինակ սրա նմանները՝
 1. verity == true
 2. Ազատվի if else֊ից օգտագործելով return֊ը։
